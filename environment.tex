% !TEX root = main.tex
%\vspace{-2mm} % TODO
\section{Interaction with the environment}

When a program interacts with its environment -- e.g., file system, environment variables, network - a symbolic executor has to take into account the whole software stack surrounding it, including system libraries, kernel, drivers, etc.

A body of early works (e.g., {\sc DART}~\cite{DART-PLDI05},  {\sc CUTE}~\cite{CUTE-FSE13}, and {\sc EXE}~\cite{EXE-CCS06}) includes the environment in symbolic analysis by actually executing external calls using concrete arguments for them. This indeed limits the behaviors they can explore compared to a fully symbolic strategy, which on the other hand might be unfeasible. 
\mytempedit{
In an online executor this choice also results in having external calls from distinct paths of execution interfere with each other. Indeed, since there is no mechanism for tracking the side effects of each external call, there is potentially a risk of state inconsistency, e.g., an execution path may read from a file while at the same time another execution path is trying to delete it.
}

%Another way to tackle the problem is to create an abstract model that captures these interactions 
\mytempedit{A way for overcoming this problem is to create abstract models that captures these interactions.} For instance, in {\sc KLEE}~\cite{KLEE-OSDI08} symbolic files are supported through a basic {\em symbolic file system} for each execution state, consisting of a directory with $n$ symbolic files whose number and sizes are specified by the user. An operation on a symbolic file results in forking $n+1$ state branches: one for each possible file, plus an optional one to capture unexpected errors in the operation. As the number of functions in a standard library is typically large and writing models for them is expensive and error-prone~\cite{Ball06}, models are generally implemented at system call-level rather than library level. This enables the symbolic exploration of the libraries as well.

{\sc AEG}~\cite{AEG-NDSS11} models most of the system environment that could be used by an attacker as input source, including the file system, network sockets, and environment variables. Additionally, more than 70 library and system calls are emulated, including thread- and process-related system calls, and common formatting functions to capture potential buffer overflows. Symbolic files are handled as in {\sc KLEE}~\cite{KLEE-OSDI08}, while symbolic sockets are dealt with in a similar manner, with packets and their payloads being processed as in symbolic files and their contents. {\sc Cloud9} further extends support to many other POSIX libraries, allowing users to also control advanced conditions in the testing environment. For instance, it can simulate reordering, delays, and packet dropping caused by a fragmented data stream over a network.

{\sc \stwoe}~\cite{CKC-TOCS12} remarks that models, other than expensive to write, rarely achieve full accuracy, and may quickly become stale if the modeled system changes. 
%\sc \stwoe}~\cite{CKC-TOCS12} remarks that models, other than expensive to write, rarely achieve full accuracy, and may quickly become stale if the modeled system changes. Hence, it would be preferable to let analyzed programs interact with the real environment while exploring multiple paths. In their \stwoe\ platform, the authors rely on virtualization to perform the desired analysis on the real software stack, preventing side effects from propagating across independent execution paths.
\mytempedit{Hence, it would be preferable to let analyzed programs interact with the real environment while exploring multiple paths. However, this must be done without incurring in environment interferences or state inconsistencies. To achieve this goal, the authors of the \stwoe\ platform rely on virtualization to perform the desired analysis on the real software stack, preventing side effects from propagating across independent execution paths. \stwoe\ exploits QEMU~\cite{QEMU-ATC05} for running the full software stack, translating guest instructions into micro-operations that can easily be run on top of the native host. Additionally, a x86-to-LLVM backend allows \stwoe\ to symbolically analyze any instruction using KLEE. By emulating the full software stack -- from the application to the operating system -- it is possible to properly evaluate any side-effects due to the environment. Whenever a symbolic branch condition is evaluated by \stwoe, a {\tt fork} operation is performed by the engine and a parallel instance of the emulator is spawned to explore the alternative path. Unfortunately, analyzing a whole-system in this manner hardly scales in practice due to the path explosion problem. For this reason, \stwoe\ has been designed for performing symbolic execution of a program without the burden of exploring any uninteresting paths that could be generated due to library and kernel code. This is achieved through the use of {\em selective symbolic execution}: this technique allows \stwoe\ to interleave symbolic (multi-path) exploration of the program code with concrete (single-path) execution of the external code. To avoid that any interesting path in the program code could be missed due to the concretization done when executing external code, \stwoe\ defines different consistency models that in turn guarantee different trade-offs with respect to the analysis correctness (see Section~\ref{ss:concrete-concolic-symbolic} for more details). For instance, \stwoe\ is able to run concretely some external code and later detect whether the concretization is impacting the symbolic exploration of the program code. Intuitively, in this case, a new concrete execution of the external code can be started, choosing different concrete input arguments in a way that can allow the engine to later explore the skipped paths. Although this approach makes it possible to properly handle most of the side effects due to the environment, the overhead of emulating the full stack can be significantly high, limiting the scalability of the overall solution.

% that possibly will allow the engine to explore the previously missed path.
%Intuitively, whenever a call to a library or kernel function is done by the program code, a single concrete execution is actually performed by the engine. Although a single concrete input instance is chosen, the engine tracks the path constraints during the concrete execution of the external code. This makes it possible to precisely characterize the input family that the chosen input instance is representative of. When returning from the external code, these path constraints are added to 
}

{\sc DART}'s approach~\cite{DART-PLDI05} is different, as the goal is to enable automated unit testing. DART deems as foreign interfaces all the external variables and functions referenced in a C program along with the arguments for a top-level function.
%External interfaces are identified by parsing the source code, and a random test driver is generated accordingly.
External functions are simulated by nondeterministically returning any value of their specified return type. Library functions are normally not considered external functions as they are controlled by the program, but in practice the user can adjust the boundary between library and external functions to simulate the desired effects.