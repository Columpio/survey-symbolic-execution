% !TEX root = main.tex
%\vspace{-2mm} % TODO
\section{Interaction with the environment and third-party components}
\label{se:environment-thirdparty}

\mytempedit{\myparagraph{Environment}}
When a program interacts with its environment -- e.g., file system, environment variables, network - a symbolic executor has to take into account the whole software stack surrounding it, including system libraries, kernel, drivers, etc.

A body of early works (e.g., {\sc DART}~\cite{DART-PLDI05},  {\sc CUTE}~\cite{CUTE-FSE05}, and {\sc EXE}~\cite{EXE-CCS06}) includes the environment in symbolic analysis by actually executing external calls using concrete arguments for them. This indeed limits the behaviors they can explore compared to a fully symbolic strategy, which on the other hand might be unfeasible. 
\mytempedit{
In an online executor this choice also results in having external calls from distinct paths of execution interfere with each other. Indeed, since there is no mechanism for tracking the side effects of each external call, there is potentially a risk of state inconsistency, e.g., an execution path may read from a file while at the same time another execution path is trying to delete it.
}

%Another way to tackle the problem is to create an abstract model that captures these interactions 
\mytempedit{A way for overcoming this problem is to create abstract models that captures these interactions.} For instance, in {\sc KLEE}~\cite{KLEE-OSDI08} symbolic files are supported through a basic {\em symbolic file system} for each execution state, consisting of a directory with $n$ symbolic files whose number and sizes are specified by the user. An operation on a symbolic file results in forking $n+1$ state branches: one for each possible file, plus an optional one to capture unexpected errors in the operation. As the number of functions in a standard library is typically large and writing models for them is expensive and error-prone~\cite{Ball06}, models are generally implemented at system call-level rather than library level. This enables the symbolic exploration of the libraries as well.

{\sc AEG}~\cite{AEG-NDSS11} models most of the system environment that could be used by an attacker as input source, including the file system, network sockets, and environment variables. Additionally, more than 70 library and system calls are emulated, including thread- and process-related system calls, and common formatting functions to capture potential buffer overflows. Symbolic files are handled as in {\sc KLEE}~\cite{KLEE-OSDI08}, while symbolic sockets are dealt with in a similar manner, with packets and their payloads being processed as in symbolic files and their contents. {\sc Cloud9} further extends support to many other POSIX libraries, allowing users to also control advanced conditions in the testing environment. For instance, it can simulate reordering, delays, and packet dropping caused by a fragmented data stream over a network.

{\sc \stwoe}~\cite{CKC-TOCS12} remarks that models, other than expensive to write, rarely achieve full accuracy, and may quickly become stale if the modeled system changes. 
%\sc \stwoe}~\cite{CKC-TOCS12} remarks that models, other than expensive to write, rarely achieve full accuracy, and may quickly become stale if the modeled system changes. Hence, it would be preferable to let analyzed programs interact with the real environment while exploring multiple paths. In their \stwoe\ platform, the authors rely on virtualization to perform the desired analysis on the real software stack, preventing side effects from propagating across independent execution paths.
\mytempedit{Hence, it would be preferable to let analyzed programs interact with the real environment while exploring multiple paths. However, this must be done without incurring in environment interferences or state inconsistencies. To achieve this goal, the authors of the \stwoe\ platform rely on virtualization to perform the desired analysis on the real software stack, preventing side effects from propagating across independent execution paths. \stwoe\ exploits QEMU~\cite{QEMU-ATC05} for running the full software stack, translating guest instructions into micro-operations that can easily be run on top of the native host. Additionally, a x86-to-LLVM backend allows \stwoe\ to symbolically analyze any instruction using KLEE. By emulating the full software stack -- from the application to the operating system -- it is possible to properly evaluate any side-effects due to the environment. Whenever a symbolic branch condition is evaluated by \stwoe, a {\tt fork} operation is performed by the engine and a parallel instance of the emulator is spawned to explore the alternative path. Unfortunately, analyzing a whole-system in this manner hardly scales in practice due to the path explosion problem. For this reason, \stwoe\ has been designed for performing symbolic execution of a program without the burden of exploring any uninteresting paths that could be generated due to library and kernel code. This is achieved through the use of {\em selective symbolic execution}: this technique allows \stwoe\ to interleave symbolic (multi-path) exploration of the program code with concrete (single-path) execution of the external code. To avoid that any interesting path in the program code could be missed due to the concretization done when executing external code, \stwoe\ defines different consistency models that in turn guarantee different trade-offs with respect to the analysis correctness (see Section~\ref{ss:concrete-concolic-symbolic} for more details). For instance, \stwoe\ is able to run concretely some external code and later detect whether the concretization is impacting the symbolic exploration of the program code. Intuitively, in this case, a new concrete execution of the external code can be started, choosing different concrete input arguments in a way that can allow the engine to later explore the skipped paths. Although this approach makes it possible to properly handle most of the side effects due to the environment, the overhead of emulating the full stack can be significantly high, limiting the scalability of the overall solution.

% that possibly will allow the engine to explore the previously missed path.
%Intuitively, whenever a call to a library or kernel function is done by the program code, a single concrete execution is actually performed by the engine. Although a single concrete input instance is chosen, the engine tracks the path constraints during the concrete execution of the external code. This makes it possible to precisely characterize the input family that the chosen input instance is representative of. When returning from the external code, these path constraints are added to 
}

{\sc DART}'s approach~\cite{DART-PLDI05} is different, as the goal is to enable automated unit testing. DART deems as foreign interfaces all the external variables and functions referenced in a C program along with the arguments for a top-level function.
%External interfaces are identified by parsing the source code, and a random test driver is generated accordingly.
External functions are simulated by nondeterministically returning any value of their specified return type. Library functions are normally not considered external functions as they are controlled by the program, but in practice the user can adjust the boundary between library and external functions to simulate the desired effects.

\mytempedit{
\myparagraph{Third-Party Components}
Similar challenges are faced when in the analysis of real-world software symbolic values flow outside the boundaries of the code being symbolically executed. Common instances of this problem are calls to, e.g., native methods in Java, unmanaged code in the .NET framework, and third-party closed-source libraries~\cite{AOH-TACAS07}.

% we should cite EXE-TECH06 but we get the same identifier :-(
Early works such as {\sc DART}~\cite{DART-PLDI05} and {\sc CUTE}~\cite{CUTE-FSE05} deal with third-party components as they do for the environment, i.e., by executing such calls using concrete arguments for them. This can result in an incomplete exploration, thus failing to generate test inputs for feasible program paths. {\sc EXE}~\cite{EXE-CCS06} instead devises a trial-and-error strategy so that calls with symbolic arguments to external library functions are logged, and the user has to manually intervene to instrument the external code and restart the exploration. This methodology aims at ensuring more complete constraint generation compared to concretization, but may require repeated interaction with the user and not scale for large functions.

A symbolic execution of third-party components poses also new challenges. For instance, an engine must account for the fact that native methods and reflection features in Java depend on the internals of the underlying Java virtual machine~\cite{Anand12}. Moreover, frameworks like Java Swing or the Android platform have important control and data flows occurring within the framework, such as callbacks for events, that would be missed by a symbolic execution of the application code only~\cite{JQF-ICSE16}.

The typical solution is thus to write a symbolic model that mimics an external component, but is more abstract and simple than it. In fact, a symbolic execution of a complex component is unlikely to succeed for a number of reasons. For instance, large components are designed with extensibility and maintainability in mind, and devise complex implementations of behaviors that appear simple externally, or contain details (e.g., the graphical representation of a feature) that might not be relevant for the symbolic exploration~\cite{JQF-ICSE16}.

However, as we discussed for the environment modeling, writing a model can be a prohibitive and error-prone task, and as in general models cannot be reused across components, applications that use unsupported ones remain out of reach. Researchers have thus devised techniques that either pinpoint the sole functions from a component that require a symbolic exploration (e.g., \cite{AOH-TACAS07,XXT-ICSE11}) and thus a model, or attempt to generate models automatically. In particular, for the second approach some works have employed program slicing (Section~\ref{ss:program-analysis}) to generate models for Android~\cite{VTV-SEN15} and Swing~\cite{CT-SEN14}. A further step towards generality is taken in~\cite{JQF-ICSE16}, which uses program synthesis to produce models for Java frameworks that make use of design patterns. The work stems from the observation that design patterns are heavily used in many components, often also for carrying out control and data flows within them. Compared to the techniques based on slicing, it can generate more concise models as program synthesis is not constrained by the structure of the implementation. We will further elaborate on program synthesis at the end of Section~\ref{ss:program-analysis}.
}