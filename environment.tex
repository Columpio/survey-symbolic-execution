% !TEX root = main.tex

\section{Interaction with the environment}

When a program interacts with its environment - e.g., file system, environment variables, network - a symbolic executor has to take into account the whole software stack surrounding it, including system libraries, kernel, drivers, etc.

A body of early works (e.g., {\sc DART}~\cite{DART-PLDI05}, {\sc CUTE}~\cite{CUTE-FSE13}, and {\sc EXE}~\cite{EXE-CCS06}) include the environment in symbolic analysis by actually executing external calls using concrete arguments for them. This indeed limits the behaviors they can explore compared to a fully symbolic strategy, which on the other hand might be unfeasible. In an online executor this choice also results in having calls from distinct execution paths interfere with each other. 

Another way to tackle the problem is to create an abstract model that captures these interactions. For instance, in {\sc KLEE}~\cite{KLEE-OSDI08} symbolic files are supported through a simple {\em symbolic file system}, which is private for each execution state. In particular, it consists of a directory with $n$ symbolic files, whose number and sizes are specified by the user. An operation on a symbolic file results in forking $n+1$ state branches: one for each possible file, plus an (optional) one to capture unexpected errors in the operation. As the number of functions in a standard library is typically large and writing models for them is an error-prone and rather expensive process~\cite{Ball06}, models are generally implemented at system call-level rather than library level. An additional benefit of this approach is that it allows for symbolic exploration of the libraries as well.

{\sc AEG}~\cite{AEG-NDSS11} models most of the system environment that an attacker can possibly use as an input source, including the file system, network sockets, and environment variables. Additionally, more than 70 library and system calls are emulated, including thread- and process-related system calls, and common formatting functions to capture potential buffer overflows. Symbolic files are handled as in {\sc KLEE}~\cite{KLEE-OSDI08}, while symbolic sockets are dealt with in a similar manner, with packets and their payloads being processed as in symbolic files and their contents. {\sc Cloud9} further extends support to many other POSIX libraries, allowing the user to also control advanced conditions in the testing environment. For instance,  {\sc Cloud9} is able to simulate delay, reordering, and dropping of packets caused by a fragmented network data stream.

{\sc \stwoe}~\cite{CKC-TOCS12} remarks that models, other than expensive to write, rarely achieve full accuracy, and also lose it as the modeled system evolves. It would be thus preferable to have analyzed programs to interact with the real environment while exploring multiple paths. In their \stwoe\ platform the authors rely on virtualization to perform the desired analysis on the real software stack, preventing side effects from propagating across independent execution paths. 

The approach followed in {\sc DART}~\cite{DART-PLDI05} is different, as the goal is to enable automated unit testing. DART deems as foreign interfaces all the external variables and functions referenced in a C program along with the arguments for a top-level function.
%External interfaces are identified by parsing the source code, and a random test driver is generated accordingly.
External functions are simulated by nondeterministically returning any value of their specified return type. Library functions are normally not considered external functions as they are controlled by the program, but in practice the user can adjust the boundary between library and external functions to simulate desired effects.