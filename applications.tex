% !TEX root = paper.tex

\section{Sample Applications}
\label{se:applications}

The last decade has witnessed an increasing adoption of symbolic execution techniques not only in the software testing domain, but also to address other compelling engineering problems such as automatic generation of exploits or authentication bypass. We now discuss \iffullver{three prominent}{prominent} applications of symbolic execution to these domains, and refer the interested reader to~\cite{CGK-ICSE11} for further scenarios.

\subsection{Bug Detection}
\label{ss:bug-detection}

Software testing strategies typically attempt to execute a program with the intent of finding bugs. As manual test input generation is an error-prone and usually non-exhaustive process, automated testing technique have drawn a lot of attention over the years. Random testing techniques such as fuzzing are cheap in terms of run-time overhead, but fail to obtain a wide exploration of a program state space. Symbolic execution techniques on the other hand achieve a more exhaustive exploration, but they become expensive as the length of the execution grows: for this reason, they usually reveal shallow bugs only.

{\em Hybrid concolic testing}~\cite{RK-ICSE07} combines random search and symbolic execution to achieve both deep program states and wide exploration in test input generation. The two techniques are interleaved: once random testing becomes unable to hit new code coverage points, symbolic execution is used to mutate the current program state by performing a bounded DFS search for an uncovered coverage point. For a fixed time budget, this technique outperforms both random testing and symbolic execution in terms of branch coverage. The intuition behind it is that many programs show behaviors where a state can be easily reached through random testing, but then a precise sequence of events -- identifiable by a symbolic engine -- is required to hit a specific coverage point.

% which uses preconstraining on the program states to ensure consistency
Driller~\cite{DRILLER-NDSS16} is a vulnerability excavation tool based on {\sc Angr}~\cite{ANGR-SSP16} that further refines this idea in order to discover memory corruption vulnerabilities. The authors remark that user inputs can be categorized as {\em general} input, which has a wide range of valid values, and {\em specific} input: a check for particular values of a specific input then splits an application into {\em compartments}. Driller offloads the majority of unique path discovery to a fuzzy engine, and relies on symbolic execution to move across compartments. 
%During the fuzzy phase, Driller marks a number of inputs as interesting (for instance, when an input was the first to trigger some state transition) and once it gets stuck in the exploration, it passes the set of such paths to a concolic engine, which preconstraints the program states to ensure consistency with the results of the native execution.
On the dataset used for the DARPA Cyber Grand Challenge qualifying event, Driller could identify crashing inputs in 77 applications, including both the 68 and 16 applications for which fuzzing and symbolic execution alone succeeded, respectively. %For 6 applications, Driller was the only one to detect a vulnerability.

\subsection{Bug Exploitation}
\label{ss:bug-exploitation}
Bugs are a consequence of the nature of human factors in software development and are everywhere. Those that can be exploited by an attacker should normally be fixed first: systems for automatically and effectively identifying them are thus very valuable.

{\sc AEG}~\cite{AEG-NDSS11} employs symbolic execution to analyze a potentially buggy program in source form and look for bugs amenable to stack smashing or return-into-libc exploits. The tool augments path constraints with exploitability constraints and queries a constraint solver, generating a concrete exploit when the constraints are satisfiable.
%The authors devise the {\em buggy-path-first} and {\em loop-exhaustion} strategies discussed in Section~\ref{ss:heuristics} to prioritize paths in the search.
On a suite of 14 Linux applications, {\sc AEG} discovered 16 vulnerabilities (2 were previously unknown) and constructed control hijack exploits for them.

{\sc Mayhem}~\cite{MAYHEM-SP12} takes another step forward by presenting the first system for binary programs that is able identify end-to-end exploitable bugs. It adopts a hybrid execution model based on checkpoints and two components: a concrete executor that injects taint-analysis instrumentation in the code and a symbolic executor that takes over when a tainted branch or jump instruction is met. Exploitability constraints for symbolic instruction pointers and format strings are generated, targeting a wide range of exploits, e.g., SEH-based and jump-to-register ones. Three path selection heuristics help prioritizing paths that are most likely to contain vulnerabilities (e.g., those containing symbolic memory accesses or instruction pointers). 
%A virtualization layer intercepts and emulates all the system calls to the host OS, while preconditioned symbolic execution can be used to reduce the size of the search space. Also, restricting symbolic execution to tainted basic blocks only gives very good speedups in this setting, as in the reported experiments more than $95\%$ of the processed instructions were not tainted.
{\sc Mayhem} was able to find exploitable vulnerabilities in the 29 Linux and Windows applications considered in the evaluation, 2 of which were previously undocumented. The generated simple exploits can be likely transformed in an automated fashion to work in the presence of classical defenses such as data execution prevention. % and address space layout randomization. 

%\vspace{-1mm} % TODO ITASEC
\subsection{Authentication Bypass}
\label{ss:auth-bypass}
Software backdoors are a method of bypassing authentication in an algorithm, a software product, or even in a full computer system. Although sometimes these software flaws are injected by external attackers using subtle tricks such as compiler tampering, there are reported cases of backdoors that have been surreptitiously installed by the hardware and/or software manufacturers, or even by governments. Using symbolic execution for analyzing the behavior of a firmware can be very convenient, especially in environments, such as embedded systems, where the documentation and the source code publicly released by the manufacturer are typically very limited or none at all.

% user-provided description of a privileged operation
Firmalice~\cite{FIRMALICE-NDSS15} is a tool that can identify authentication bypass flaws inside firmwares running on devices such as routers and printers. Given a description of a privileged operation in the device, Firmalice identifies a set of program points that, if executed, forces the privileged operation to be performed. The program slice that involves the privileged program points is then symbolically analyzed using {\sc Angr}~\cite{ANGR-SSP16}. If any such point can be reached by the engine, an SMT solver can generate a set of concrete inputs for it that can be then used to effectively bypass authentication inside the device. On three commercially available devices, Firmalice could detect vulnerabilities in two of them, and determine that a backdoor in the third firmware is not remotely exploitable.