% !TEX root = paper.tex

\subsection{Memory Model}
\label{ss:memory}

%How does the symbolic engine handle pointers, arrays, or other complexobjects? Any arbitrarily complex object can be regarded as an array of bytes and each byte associated with a distinct symbol. However, when possible, exploiting structural properties of the data may be more convenient: for instance, relational bounds on the class fields in object-oriented languages could be used for refining the search performed by symbolic execution.

% of Section~\ref{symbolic-execution-example}
Our warm-up example presented a simplified memory model where data are stored in scalar variables only, with no indirection. A crucial aspect of symbolic execution is how memory should be modeled to support programs with pointers and arrays. This requires extending our notion of memory store by mapping not only variables, but also memory addresses to symbolic expressions or concrete values.
%In general, a store $\sigma$ that explicitly models memory addresses can be thought as a mapping that associates memory addresses with either expressions over concrete values or symbolic values.
A memory model is an important design choice for a symbolic engine, as it can have a significant influence on the coverage achieved by symbolic execution, as well as on the scalability of constraint solving. In fact, the {\em symbolic memory address} problem~\cite{SAB-SP10}  arises when the address referenced in the operation is a symbolic expression.

\myparagraph{Fully Symbolic Memory} At the one end of the design spectrum, an engine may treat memory addresses as fully symbolic. This is the approach taken by a number of works (e.g., {\sc BitBlaze}~\cite{BITBLAZE-ICISS08} and {\sc BAP}~\cite{BAP-CAV11}). Two mechanisms, pioneered by King in its seminal paper~\cite{K-CACM76}, can be used:

\begin{itemize}

\item {\em State forking.} If an operation reads from or writes to a symbolic address, the state is forked by considering all possible states that may result from the operation. The path constraints are updated accordingly for each forked state.

\item {\em if-then-else formulas.} The uncertainty on the possible values of a symbolic pointer can be encoded into the expressions kept in the symbolic store and in the path constraints, without forking any new states. The key idea is to exploit the capability of some solvers to reason on if-then-else expressions of the form $ite(\texttt{c}, \texttt{t}, \texttt{f})$, which yields \texttt{t} if \texttt{c} is true, and \texttt{f} otherwise. %\footnote{In propositional logic, the $ite(\texttt{c}, \texttt{t}, \texttt{f})$ expression could be replaced with the formula $(\texttt{c} \wedge \texttt{t}) \vee (\neg\texttt{c} \wedge \texttt{f})$.}
%The $ite$ approach is used, e.g., in {\sc Angr}~\cite{ANGR-SSP16}.
\end{itemize}

\noindent In general, a symbolic address may reference any cell in memory, making the approaches described above intractable. Fortunately, in many practical cases the set of possible addresses a memory operation may reference is small~\cite{BITBLAZE-ICISS08}. To model fully symbolic pointers, an extensive line of research  (e.g., {\sc EXE}~\cite{EXE-CCS06}, {\sc KLEE}~\cite{KLEE-OSDI08}, {\sc SAGE}~\cite{EGL-ISSTA09}) leverages the expressive power of some SMT solvers, which can model operations on arrays using {\em theories of arrays} in their decision procedures~\cite{STP-CAV07}. 

% SAGE-NDSS08, now EGL-ISSTA09
\myparagraph{Address Concretization}
In all cases where the combinatorial complexity of the analysis explodes as pointer values cannot be bounded to sufficiently small ranges, a popular alternative is {\em address concretization}, which consists in concretizing a pointer to a single specific address. This can reduce the number of states and the complexity of the formulas fed to the solver and thus improve running time, although may cause the engine to miss paths that, for instance, depend on specific values for some pointers. Concretization is empoyed, e.g., in {\sc DART}~\cite{DART-PLDI05} and in early {\sc SAGE} releases~\cite{EGL-ISSTA09}. {\sc CUTE}~\cite{CUTE-FSE13} is capable of reasoning only about equality constraints for pointers, as they can be solved efficiently, and resorts to concretization for general symbolic references. % equality and inequality

%we normally get or set a concrete value at a particular memory address. When executing symbolically, a design choice for a symbolic engine concerns what to do when a memory reference is an expression instead of a concrete address.

\myparagraph{Partial Memory Modeling}
To mitigate the scalability problems of fully symbolic memory and the loss of soundness from concretization, {\sc Mayhem}~\cite{MAYHEM-SP12} explores a middle point in the spectrum by introducing a {\em partial} memory model. The key idea is that written addresses are always concretized and read addresses are modeled symbolically if the set of possible values they may assume is small enough, employing a number of techniques to refine its size. This model is based on a trade-off: it uses more expressive formulas than concretization, since it encodes multiple pointer values per state, but does not attempt to encode all of them like in fully symbolic memory.%~\cite{MAYHEM-THESIS}.

%A basic approach to bound the set of possible values that an address may assume consists in trying different concrete values and checking whether they satisfy the current path constraints, excluding large portions of the address space at each trial until a tight range is found. 