% !TEX root = main.tex

\section{Symbolic Execution Engines}
\label{se:executors}

In this section we describe some important principles for the design of symbolic executors as well as crucial tradeoffs that arise in their implementation. Moving from the concepts of concrete and symbolic runs, we also introduce the idea of {\em concolic execution}.

\subsection{Concrete, Symbolic, and Concolic Execution}
\label{ss:concrete-concolic-symbolic}

As shown in the warm-up example of Section~\ref{symbolic-execution-example}, a symbolic execution of a program can generate -- in theory -- all possible control flow paths that the program could take during a concrete execution on a specific input. While modelling all possible runs allows for very interesting analyses, it is typically unfeasible in practice, especially on real-world software, for a variety of reasons.

First, as extensively discussed in Section~\ref{se:path-explosion}, the number of control flow paths to be generated and analyzed could be prohibitively large, due to branch instructions and loops. In the worst case, if the code contains an unbounded loop, the symbolic execution could keep running forever, generating a potentially infinite number of paths (see also Section~\ref{se:loops} for loop handling strategies).

Moreover, symbolic engines are clients of SMT constraint solvers, which are continuously invoked during the analysis. Even if powerful SMT solvers are currently available, the time spent in constraint solving is still one of the main performance barriers for symbolic execution. Moreover, while an SMT solver should support as many decidable logical fragments as possible and some symbolic executors use even more than one solver, it may happen that the program yields constraints that the solver does not handle well (e.g., non-linear constraints).
%An SMT instance is a formula in first-order logic, where some function and predicate symbols have additional meaning. This meaning depends on the theory being used: for instance, with linear inequalities symbols with extra meaning include the integers, $+$, $-$, $x$, $\le$. Path constraints are typically expressed in a decidable logical fragment without quantifiers

{\bf Irene:  STOPPED HERE, MUST CONTINUE FROM THIS POINT}
 
A standard approach to handle non-linear constraints and external environment is to mix concrete and symbolic execution.\\
-- leads to under-approximation
[...]

Concolic Execution: combines both symbolic execution and concrete (normal) execution.
The basic idea is to have the concrete execution drive the symbolic execution.


\paragraph{Execution-Generated Testing (EGT)} 
\mynote{[D] This belongs here} Approach used by some papers (e.g.,~\cite{KLEE-OSDI08,EXE-CCS06}) that works by making a distinction between the concrete and symbolic state of a program: if an operation involves only concrete values, then the symbolic engine concretely execute it. This can allow symbolic execution to reason even over complex operation (e.g., non linear operations) if they involve only concrete values. EGT is often seen (\cite{CS-CACM13}) as a form of dynamic symbolic execution: this can be seen as more general term than concolic execution.

\subsection{Principles of Symbolic Executors}\mynote{[D] Entirely rewritten}
\label{ss:principles}

\cite{MAYHEM-SP12} discusses a number design principles that a symbolic execution engine should follow, most notably: 
%A symbolic execution engine should guarantee three main principles (\cite{MAYHEM-SP12}):
\begin{enumerate}
  \item the system should be able to make forward progress for an arbitrarily long time (ideally forever) without exceeding the given resources;
  \item to maximize performance, no work should be repeated (e.g., avoid restarting symbolic/concrete execution of a program from the beginning);
  \item the system should reuse as much as possible previous analysis results.
\end{enumerate}

\noindent Based on these principles, symbolic executors can be divided into:

\begin{itemize}
  \item {\em offline} executors (e.g., \cite{SAGE-NDSS08}), which reason about a single path at a time. As each path is run independently of the others, results from previous runs can be immediately reused. Runs are concrete and require an input seed; the recorded trace of instructions is then executed symbolically;
 %one path at time, every run independent from the others, results can be immediately reused, each run restarts the execution of the program from the beginning. In order to perform a run, two inputs must be provided: the target program and a seed input. The program is concretely executed and a trace is recorded. Then the trace is symbolically executed. This can be seen as a form of {\em concolic} execution (see Section~\ref{ss:concrete-concolic-symbolic}).
  \item {\em online} executors (e.g., \cite{KLEE-OSDI08,CKC-TOCS12,AEG-NDSS11}, which clone the execution state at each input-dependent branch. No previous instruction is re-executed, but the continuous forking puts a burden on memory and eventually slows down the engine as the exploration proceeds. Also, isolation between states must be ensured (e.g., by emulating the effects of system calls);
%for each fork, the execution state is cloned. All active execution states are kept in memory, no need to re-execute but huge burden on memory resources. A form of {\em context switch} is often needed. Executors may stop forking at a certain point to allow progress, but then some path are ignored. Memory is saved by aggressive copy-on-write optimization (e.g., immutable state). DFS can be used as exploration strategy in order to minimize memory consumption but can be very slow at doing progress. Notice that since multiple runs may be executed in parallel, isolation must be guaranteed (e.g., keeping different states of the OS by emulating system calls).
  \item {\em hybrid} executors (e.g., \cite{MAYHEM-SP12}), which start in online mode and generate checkpoints rather than fork when memory usage or the number of concurrently active states reaches a threshold. Checkpoints maintain the symbolic execution state and replay information. When a checkpoint is picked for restoration, the concrete state is restored and the online exploration resumes.
%: mixed approach. Start with an online approach, if needed switch to offline mode by doing checkpoints. A checkpoint contains the symbolic execution state and replay information. Concrete execution state is discarded since it can be quickly recovered at runtime by using one input generated by the solver before checkpointing.
\end{itemize}

\subsection{Consistency in Concolic Executors} \mynote{Provisionally placed here} % Selective symbolic execution?

When exploring multiple paths at a time, an execution engine may execute some portions of code concretely, interleaving them with fully symbolic phases. This process, also known as {\em selective symbolic execution}, is useful to analyze a program across a full software stack without sacrificing scalability. However, it must be done carefully in order to preserve the meaningfulness of the whole exploration.

When an argument $x$ for a function call to concretize is symbolic, the engine should convert it to some concrete value in order to perform the call. Compared to the family of possible paths from executing the call symbolically, this is equivalent to corseting the exploration to a single path in the callee. When the call returns and the symbolic phase resumes, the concrete value for $x$ becomes part of the path constraints for the remainder of the exploration. However, a large number of paths may then be excluded.

\cite{CKC-TOCS12} presents the first systematic approach to consistently cross the symbolic/concrete boundary in both directions. The work describes a strategy to deal with constraints introduced on symbolic values as a consequence of concretization, and introduces a number of consistency models - where a state is {\em consistent} when there exists a feasible path to it from the initial state - which suit different analyses.

Constraints updated to account for concrete values are marked as {\em soft}, and whenever a branch in the symbolic domain is disabled because of a soft constraint, execution goes back and picks a value for the concrete call that would enable that branch.

%When execution returns to the symbolic domain, we have observed that updating constraints to reflect a concrete assignment might result in a corseting of the family of future paths that can be explored. Such constraints are marked in ~\cite{CKC-TOCS12} as {\em soft}, and whenever a branch in the symbolic domain is disabled because of a soft constraint, execution goes back and picks a value for the concrete call that would enable that branch.

\subsection{Tools}
A list of symbolic execution engines is presented in Table~\ref{tab:symbolic-engines}.

\begin{figure}[t]
  \centering
  \begin{adjustbox}{width=1\columnwidth}
  %\begin{small}
  \begin{tabular}{| l || c || l |}
    \hline      
    Symbolic engine & Paper(s) & Project URL  \\ \hline\hline
    {\tt Check \textsc{\char13}n\textsc{\char13} Crash} & \cite{CS-ICSE05} & \url{http://ranger.uta.edu/~csallner/cnc/}\\
    {\tt CUTE} & \cite{CUTE-FSE13} & -- \\
    {\tt DART} & \cite{DART-PLDI05} & -- \\
    {\tt jCUTE} & \cite{SA-CAV06} & \url{https://github.com/osl/jcute} \\ % : Java Concolic Unit Testing Engine
    {\tt KLEE} & \cite{EXE-CCS06,KLEE-OSDI08} & \url{https://klee.github.io/} \\ % : a LLVM Execution Engine
    {\tt SAGE} & \cite{SAGE-NDSS08} & -- \\
    {\tt CREST} & \cite{CREST-ASE08} & \url{https://github.com/jburnim/crest} \\ % : a concolic test generation tool for C
    {\tt PEX} & \cite{PEX-TAP08} & \url{http://research.microsoft.com/en-us/projects/pex/} \\
    {\tt Rubyx} & \cite{CF-CCS10} & -- \\
    {\tt Java PathFinder} & \cite{PATHFINDER-ASE10} & \url{http://babelfish.arc.nasa.gov/trac/jpf}\\
    {\tt Otter} & \cite{RSM-ICSE10} & \url{https://bitbucket.org/khooyp/otter/} \\
    {\tt BAP} & \cite{BAP-CAV11} & \url{https://github.com/BinaryAnalysisPlatform/bap} \\
    {\tt Mayhem} & \cite{MAYHEM-SP12} & -- \\
    {\tt SymDroid} & \cite{JMF-TECH12} & -- \\
    {\tt \stwoe} & \cite{CKC-TOCS12} & \url{http://s2e.epfl.ch/} \\
    {\tt FuzzBALL} & \cite{MMP-ASPLOS12,FUZZBALL-ESORICS13} & \url{http://bitblaze.cs.berkeley.edu/fuzzball.html} \\
    {\tt Jalangi} & \cite{SKB-FSE13} & \url{https://github.com/Samsung/jalangi2} \\
    {\tt Pathgrind} & \cite{S-ICSE04} & \url{https://github.com/codelion/pathgrind} \\
    {\tt Kite} & \cite{V-THESIS14} & \url{http://www.cs.ubc.ca/labs/isd/Projects/Kite} \\
    {\tt SymJS} & \cite{LAG-FSE14} & -- \\
    {\tt CIVL} & \cite{CIVL-TECH14} & \url{http://vsl.cis.udel.edu/civl/}\\ % : The Concurrency Intermediate Verification Language 
	{\tt KeY} & \cite{HBR-RV14} & \url{http://www.key-project.org/} \\
    {\tt angr} & \cite{FIRMALICE-NDSS15,ANGR-SSP16} & \url{http://angr.io/} \\

    {\tt CATG} & -- & \url{https://github.com/ksen007/janala2} \\
    {\tt PySymEmu} & -- & \url{https://github.com/feliam/pysymemu/} \\
    {\tt Triton} & -- & \url{http://triton.quarkslab.com/} \\
    \hline  
  \end{tabular}
  %\end{small}
  \end{adjustbox}
  \caption{List of tools.}
  \label{tab:symbolic-engines}
\end{figure}

